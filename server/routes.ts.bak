import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer } from "ws";
import { storage } from "./storage";
import { setupAuth } from "./auth";
import { createGoogleMeetEvent, isGoogleCalendarConnected } from "./google-calendar-integration";
import multer from 'multer';
import path from 'path';

const multerStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ storage: multerStorage });

function requireAuth(req: any, res: any, next: any) {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø© Ù…Ø·Ù„ÙˆØ¨Ø©" });
  }
  next();
}

function requireRole(roles: string[]) {
  return (req: any, res: any, next: any) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ message: "ØºÙŠØ± Ù…ØµØ±Ø­ Ù„Ùƒ Ø¨Ø§Ù„ÙˆØµÙˆÙ„" });
    }
    next();
  };
}

export function registerRoutes(app: Express): Server {
  setupAuth(app);

  // Task routes
  app.get("/api/tasks", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const tasks = await storage.getAllTasks();
      res.json(tasks);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù‡Ø§Ù…" });
    }
  });

  app.get("/api/tasks/my", requireAuth, async (req, res) => {
    try {
      const tasks = await storage.getUserTasks(req.user!.id);
      res.json(tasks);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù‡Ø§Ù…" });
    }
  });

  app.get("/api/tasks/assigned", requireAuth, async (req, res) => {
    try {
      const tasks = await storage.getAssignedTasks(req.user!.id);
      res.json(tasks);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¹ÙŠÙ†Ø©" });
    }
  });

  app.get("/api/tasks/:id", requireAuth, async (req, res) => {
    try {
      const task = await storage.getTask(req.params.id);
      if (!task) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ù‡Ù…Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      res.json(task);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù‡Ù…Ø©" });
    }
  });

  app.post("/api/tasks", requireAuth, async (req, res) => {
    try {
      const taskData = {
        ...req.body,
        createdBy: req.user!.id,
        companyName: req.body.companyName || null,
        assignedTo: req.body.assignedTo || null,
        // Convert ISO string dates to Date objects for Drizzle
        dueDate: req.body.dueDate ? new Date(req.body.dueDate) : undefined,
      };
      const task = await storage.createTask(taskData);
      
      // Send notification if assigned to someone
      if (task.assignedTo && task.assignedTo !== req.user!.id) {
        await storage.createNotification({
          userId: task.assignedTo,
          title: "Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ø¹ÙŠÙ†Ø© Ù„Ùƒ",
          message: `ØªÙ… ØªØ¹ÙŠÙŠÙ† Ù…Ù‡Ù…Ø© "${task.title}" Ù„Ùƒ`,
          type: "info",
          category: "task",
          metadata: {
            resourceId: task.id,
            taskId: task.id,
            userId: req.user!.id,
            userName: req.user!.fullName,
            userAvatar: req.user!.profilePicture || undefined
          }
        });
      }
      
      res.status(201).json(task);
    } catch (error) {
      console.error("Error creating task:", error instanceof Error ? error.message : error, error instanceof Error ? error.stack : "");
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù‡Ù…Ø©", error: error instanceof Error ? error.message : String(error) });
    }
  });

  app.put("/api/tasks/:id", requireAuth, async (req, res) => {
    try {
      // Get the existing task first
      const existingTask = await storage.getTask(req.params.id);
      if (!existingTask) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ù‡Ù…Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      // Prepare update data with date conversions
      const updateData = {
        ...req.body,
        dueDate: req.body.dueDate ? new Date(req.body.dueDate) : undefined,
      };


      // Check if trying to update status to 'completed'
      if (req.body.status === 'completed') {
        const isCreator = existingTask.createdBy === req.user!.id;
        const isAdminOrSubAdmin = req.user!.role === 'admin' || req.user!.role === 'sub-admin';

        if (isCreator || isAdminOrSubAdmin) {
          // Allow direct completion and set completedAt
          const task = await storage.updateTask(req.params.id, {
            ...updateData,
            completedAt: new Date()
          });
          res.json(task);
        } else {
          // Change status to 'under_review' instead
          const task = await storage.updateTask(req.params.id, {
            ...updateData,
            status: 'under_review'
          });

          // Notify the task creator
          if (existingTask.createdBy) {
            await storage.createNotification(
              existingTask.createdBy,
              "Ù…Ù‡Ù…Ø© Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©",
              `Ø§Ù„Ù…Ù‡Ù…Ø© "${existingTask.title}" Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©`,
              "info"
            );
          }

          res.json(task);
        }
      } else {
        // Normal update for other status changes
        const task = await storage.updateTask(req.params.id, updateData);
        res.json(task);
      }
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù‡Ù…Ø©" });
    }
  });

  app.delete("/api/tasks/:id", requireAuth, async (req, res) => {
    try {
      const task = await storage.getTask(req.params.id);
      if (!task) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ù‡Ù…Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      // Check authorization
      if (task.createdBy !== req.user!.id && req.user!.role !== 'admin' && req.user!.role !== 'sub-admin') {
        return res.status(403).json({ message: "ØºÙŠØ± Ù…ØµØ±Ø­ Ù„Ùƒ Ø¨Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù‡Ù…Ø©" });
      }
      const success = await storage.deleteTask(req.params.id);
      if (!success) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ù‡Ù…Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      res.json({ message: "ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ù‡Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­" });
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ù‡Ù…Ø©" });
    }
  });

  // Task comments/notes routes
  app.get("/api/tasks/:id/comments", requireAuth, async (req, res) => {
    try {
      const comments = await storage.getTaskNotes(req.params.id);
      res.json(comments);
    } catch (error) {
      console.error("Error fetching task comments:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª" });
    }
  });

  app.post("/api/tasks/:id/comments", requireAuth, async (req, res) => {
    try {
      const comment = await storage.createTaskNote(
        req.params.id,
        req.user!.id,
        req.body.content
      );
      res.status(201).json(comment);
    } catch (error) {
      console.error("Error creating task comment:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØ¹Ù„ÙŠÙ‚" });
    }
  });


  // Task review and rating routes
  app.put("/api/tasks/:id/submit-review", requireAuth, async (req, res) => {
    try {
      const task = await storage.getTask(req.params.id);
      if (!task) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ù‡Ù…Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      
      if (task.assignedTo !== req.user!.id && task.createdBy !== req.user!.id) {
        return res.status(403).json({ message: "ØºÙŠØ± Ù…ØµØ±Ø­ Ù„Ùƒ Ø¨ØªÙ‚Ø¯ÙŠÙ… Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù‡Ù…Ø© Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©" });
      }
      
      const updatedTask = await storage.updateTask(req.params.id, { status: 'under_review' });
      
      if (task.createdBy && task.createdBy !== req.user!.id) {
        await storage.createNotification(
          task.createdBy,
          "Ù…Ù‡Ù…Ø© Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©",
          `Ø§Ù„Ù…Ù‡Ù…Ø© "${task.title}" Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©`,
          "info"
        );
      }
      
      res.json(updatedTask);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ù…Ù‡Ù…Ø© Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©" });
    }
  });

  app.put("/api/tasks/:id/approve-review", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const task = await storage.approveTaskReview(req.params.id, req.user!.id);
      if (!task) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ù‡Ù…Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      
      if (task.assignedTo) {
        await storage.createNotification(
          task.assignedTo,
          "ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù‡Ù…Ø©",
          `ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ù…Ù‡Ù…ØªÙƒ "${task.title}" ÙˆØªÙ… Ø¥ÙƒÙ…Ø§Ù„Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­`,
          "success"
        );
      }
      
      res.json(task);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù‡Ù…Ø©" });
    }
  });

  app.put("/api/tasks/:id/rate", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const { rating } = req.body;
      if (!rating || rating < 1 || rating > 5) {
        return res.status(400).json({ message: "ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨ÙŠÙ† 1 Ùˆ 5" });
      }
      
      const existingTask = await storage.getTask(req.params.id);
      if (!existingTask) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ù‡Ù…Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      
      if (existingTask.performanceRating) {
        return res.status(400).json({ message: "ØªÙ… ØªÙ‚ÙŠÙŠÙ… Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù‡Ù…Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹" });
      }
      
      const task = await storage.rateTask(req.params.id, rating, req.user!.id);
      
      if (task.assignedTo) {
        await storage.createNotification(
          task.assignedTo,
          "ØªÙ… ØªÙ‚ÙŠÙŠÙ… Ù…Ù‡Ù…ØªÙƒ",
          `ØªÙ… ØªÙ‚ÙŠÙŠÙ… Ù…Ù‡Ù…ØªÙƒ "${task.title}" Ø¨Ù€ ${rating} Ù†Ù‚Ø§Ø·`,
          "info"
        );
      }
      
      res.json(task);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù…Ù‡Ù…Ø©" });
    }
  });

  app.put("/api/tasks/:id/assign-points", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const { rewardPoints } = req.body;
      
      if (rewardPoints === undefined || rewardPoints === null || typeof rewardPoints !== 'number' || rewardPoints < 0) {
        return res.status(400).json({ message: "ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ¯ Ù†Ù‚Ø§Ø· Ù…ÙƒØ§ÙØ£Ø© ØµØ­ÙŠØ­Ø©" });
      }

      const existingTask = await storage.getTask(req.params.id);
      if (!existingTask) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ù‡Ù…Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }

      const task = await storage.updateTask(req.params.id, { rewardPoints });

      if (task.assignedTo) {
        const assignedUser = await storage.getUser(task.assignedTo);
        if (assignedUser) {
          const newTotalPoints = (assignedUser.totalPoints || 0) + rewardPoints;
          await storage.updateUser(task.assignedTo, { totalPoints: newTotalPoints });

          await storage.createNotification(
            task.assignedTo,
            "Ù†Ù‚Ø§Ø· Ù…ÙƒØ§ÙØ£Ø© Ø¬Ø¯ÙŠØ¯Ø©",
            `ØªÙ… Ù…Ù†Ø­Ùƒ ${rewardPoints} Ù†Ù‚Ø·Ø© Ù…ÙƒØ§ÙØ£Ø© Ù„Ù„Ù…Ù‡Ù…Ø© "${task.title}"`,
            "success"
          );
        }
      }

      res.json(task);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ¹ÙŠÙŠÙ† Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©" });
    }
  });

  // AUX Session routes
  app.post("/api/aux/start", requireAuth, async (req, res) => {
    try {
      const session = await storage.startAuxSession({
        userId: req.user!.id,
        status: req.body.status,
        notes: req.body.notes,
      });
      res.json(session);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¨Ø¯Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø©" });
    }
  });

  app.post("/api/aux/end/:id", requireAuth, async (req, res) => {
    try {
      const session = await storage.endAuxSession(req.params.id, req.body.notes);
      if (!session) {
        return res.status(404).json({ message: "Ø§Ù„Ø¬Ù„Ø³Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      res.json(session);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø©" });
    }
  });

  app.get("/api/aux/current", requireAuth, async (req, res) => {
    try {
      const session = await storage.getCurrentAuxSession(req.user!.id);
      res.json(session);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©" });
    }
  });

  app.get("/api/aux/sessions", requireAuth, async (req, res) => {
    try {
      const startDate = req.query.startDate ? new Date(req.query.startDate as string) : undefined;
      const endDate = req.query.endDate ? new Date(req.query.endDate as string) : undefined;
      const sessions = await storage.getUserAuxSessions(req.user!.id, startDate, endDate);
      res.json(sessions);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¬Ù„Ø³Ø§Øª" });
    }
  });

  // Admin routes
  app.get("/api/admin/employees", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const employees = await storage.getAllActiveAuxSessions();
      res.json(employees);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ†" });
    }
  });

  app.get("/api/admin/stats", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const stats = await storage.getSystemStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª" });
    }
  });

  // Users routes
  app.get("/api/users", requireAuth, async (req, res) => {
    try {
      const users = await storage.getUsers();
      res.json(users.map(user => ({
        id: user.id,
        fullName: user.fullName,
        email: user.email,
        department: user.department,
        jobTitle: user.jobTitle,
        role: user.role,
        isActive: user.isActive,
        profilePicture: user.profilePicture,
        totalPoints: user.totalPoints, // Ø¥Ø¶Ø§ÙØ© totalPoints
      })));
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†" });
    }
  });

  app.post("/api/admin/employees", requireAuth, requireRole(['admin']), async (req, res) => {
    try {
      const bcrypt = await import('bcrypt');
      const hashedPassword = await bcrypt.hash(req.body.password || 'Employee@123', { saltRounds: 10 });
      
      const newEmployee = await storage.createUser({
        email: req.body.email,
        password: hashedPassword,
        fullName: req.body.fullName,
        department: req.body.department,
        jobTitle: req.body.jobTitle,
        role: req.body.role || 'employee',
        phoneNumber: req.body.phoneNumber,
        address: req.body.address,
        salary: req.body.salary || 0,
        hireDate: req.body.hireDate || new Date(),
        isActive: true,
      });
      
      res.status(201).json({
        id: newEmployee.id,
        fullName: newEmployee.fullName,
        email: newEmployee.email,
        department: newEmployee.department,
        jobTitle: newEmployee.jobTitle,
        role: newEmployee.role
      });
    } catch (error) {
      console.error("Error creating employee:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ÙˆØ¸Ù" });
    }
  });

  app.put("/api/admin/employees/:id", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const updates: any = {
        fullName: req.body.fullName,
        department: req.body.department,
        jobTitle: req.body.jobTitle,
        role: req.body.role, // Ø¥Ø¶Ø§ÙØ© role
        phoneNumber: req.body.phoneNumber,
        address: req.body.address,
        salary: req.body.salary,
        isActive: req.body.isActive,
      };
      
      const updatedEmployee = await storage.updateUser(req.params.id, updates);
      if (!updatedEmployee) {
        return res.status(404).json({ message: "Ø§Ù„Ù…ÙˆØ¸Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      
      res.json(updatedEmployee);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ¸Ù" });
    }
  });

  app.delete("/api/admin/employees/:id", requireAuth, requireRole(['admin']), async (req, res) => {
    try {
      // Prevent deleting yourself
      if (req.params.id === req.user!.id) {
        return res.status(400).json({ message: "Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø­Ø°Ù Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ø®Ø§Øµ" });
      }

      const success = await storage.deleteUser(req.params.id);
      if (!success) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      
      res.json({ message: "ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­" });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
    }
  });

  // Profile routes
  app.get("/api/profile/:id", requireAuth, async (req, res) => {
    try {
      const users = await storage.getUsers();
      const user = users.find(u => u.id === req.params.id);
      if (!user) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      res.json({
        id: user.id,
        email: user.email,
        fullName: user.fullName,
        department: user.department,
        jobTitle: user.jobTitle,
        role: user.role,
        profilePicture: user.profilePicture,
        coverImage: user.coverImage,
        bio: user.bio,
        phoneNumber: user.phoneNumber,
        address: user.address,
        dateOfBirth: user.dateOfBirth,
        hireDate: user.hireDate,
        isActive: user.isActive,
        totalPoints: user.totalPoints, // Ø¥Ø¶Ø§ÙØ© totalPoints
      });
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ" });
    }
  });

  app.put("/api/profile", requireAuth, upload.fields([
    { name: 'profilePicture', maxCount: 1 },
    { name: 'coverImage', maxCount: 1 }
  ]), async (req, res) => {
    try {
      const updates: any = {
        fullName: req.body.fullName,
        department: req.body.department,
        jobTitle: req.body.jobTitle,
        bio: req.body.bio,
        phoneNumber: req.body.phoneNumber,
        address: req.body.address,
        dateOfBirth: req.body.dateOfBirth,
        hireDate: req.body.hireDate,
      };

      // Handle file uploads
      if (req.files && req.files['profilePicture']) {
        const file = req.files['profilePicture'][0];
        updates.profilePicture = `/uploads/${file.filename}`;
      }
      if (req.files && req.files['coverImage']) {
        const file = req.files['coverImage'][0];
        updates.coverImage = `/uploads/${file.filename}`;
      }

      const updatedUser = await storage.updateUser(req.user!.id, updates);
      if (!updatedUser) {
        return res.status(404).json({ message: "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ" });
    }
  });

  // Leave requests routes
  app.post("/api/leaves", requireAuth, async (req, res) => {
    try {
      // Parse dates from YYYY-MM-DD format
      const startDateStr = req.body.startDate;
      const endDateStr = req.body.endDate;
      
      if (!startDateStr || !endDateStr) {
        return res.status(400).json({ message: "ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙˆØ§Ù„Ù†Ù‡Ø§ÙŠØ©" });
      }
      
      // Create dates at midnight local time
      const [startYear, startMonth, startDay] = startDateStr.split('-').map(Number);
      const [endYear, endMonth, endDay] = endDateStr.split('-').map(Number);
      
      const startDate = new Date(startYear, startMonth - 1, startDay, 0, 0, 0);
      const endDate = new Date(endYear, endMonth - 1, endDay, 23, 59, 59);
      
      // Validate dates
      if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
        return res.status(400).json({ message: "ØªÙˆØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­Ø©" });
      }
      
      if (startDate > endDate) {
        return res.status(400).json({ message: "ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ Ø£Ùˆ ÙŠØ³Ø§ÙˆÙŠ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ©" });
      }
      
      // Calculate inclusive day count (at least 1)
      const days = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));



















      
      // Explicitly construct payload with whitelisted fields only
      const leaveRequest = await storage.createLeaveRequest({
        userId: req.user!.id,
        type: req.body.type,
        startDate: startDate,
        endDate: endDate,
        days,
        reason: req.body.reason || '',
      });
      
      // Notify admins
      const admins = await storage.getUsers();
      const adminUsers = admins.filter(u => u.role === 'admin' || u.role === 'sub-admin');
      
      for (const admin of adminUsers) {
        const notification = await storage.createNotification(
          admin.id,
          "Ø·Ù„Ø¨ Ø¥Ø¬Ø§Ø²Ø© Ø¬Ø¯ÙŠØ¯",
          `${req.user!.fullName} Ù‚Ø¯Ù… Ø·Ù„Ø¨ Ø¥Ø¬Ø§Ø²Ø© Ø¬Ø¯ÙŠØ¯`,
          "info"
        );
        
        // Broadcast notification via WebSocket
        wss.clients.forEach((client) => {
          if (client.readyState === client.OPEN) {
            client.send(JSON.stringify({
              type: 'new_notification',
              data: notification
            }));
          }
        });
      }
      
      res.status(201).json(leaveRequest);
    } catch (error) {
      console.error('Error creating leave request:', error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø¬Ø§Ø²Ø©" });
    }
  });

  app.get("/api/leaves/my", requireAuth, async (req, res) => {
    try {
      const requests = await storage.getUserLeaveRequests(req.user!.id);
      res.json(requests);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¥Ø¬Ø§Ø²Ø§Øª" });
    }
  });

  app.get("/api/leaves/pending", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const requests = await storage.getPendingLeaveRequests();
      res.json(requests);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¥Ø¬Ø§Ø²Ø§Øª" });
    }
  });

  app.put("/api/leaves/:id", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const updates = {
        ...req.body,
        approvedBy: req.user!.id,
        approvedAt: new Date(),
      };
      
      const leaveRequest = await storage.updateLeaveRequest(req.params.id, updates);
      if (!leaveRequest) {
        return res.status(404).json({ message: "Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø¬Ø§Ø²Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      
      // Notify employee
      const statusText = leaveRequest.status === 'approved' ? 'ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰' : 'ØªÙ… Ø±ÙØ¶';
      const notification = await storage.createNotification(
        leaveRequest.userId,
        "ØªØ­Ø¯ÙŠØ« Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø¬Ø§Ø²Ø©",
        `${statusText} Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø¬Ø§Ø²Ø© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ`,
        leaveRequest.status === 'approved' ? 'success' : 'error'
      );
      
      // Broadcast notification via WebSocket
      wss.clients.forEach((client) => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify({
            type: 'new_notification',
            data: notification
          }));
        }
      });
      
      res.json(leaveRequest);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø¬Ø§Ø²Ø©" });
    }
  });

  // Salary Advance Request routes
  app.post("/api/salary-advances", requireAuth, async (req, res) => {
    try {
      const advanceRequest = await storage.createSalaryAdvanceRequest({
        userId: req.user!.id,
        amount: req.body.amount,
        reason: req.body.reason,
        repaymentDate: req.body.repaymentDate ? new Date(req.body.repaymentDate) : null,
      });
      
      res.status(201).json(advanceRequest);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø§Ù„Ø³Ù„ÙØ©" });
    }
  });

  app.get("/api/salary-advances/pending", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const requests = await storage.getPendingSalaryAdvanceRequests();
      res.json(requests);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø³Ù„Ù" });
    }
  });

  app.get("/api/salary-advances/user", requireAuth, async (req, res) => {
    try {
      const requests = await storage.getUserSalaryAdvanceRequests(req.user!.id);
      res.json(requests);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø³Ù„Ù" });
    }
  });

  app.put("/api/salary-advances/:id", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const updates = {
        ...req.body,
        approvedBy: req.user!.id,
        approvedAt: new Date(),
      };
      
      const advanceRequest = await storage.updateSalaryAdvanceRequest(req.params.id, updates);
      if (!advanceRequest) {
        return res.status(404).json({ message: "Ø·Ù„Ø¨ Ø§Ù„Ø³Ù„ÙØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      
      // Notify employee
      const statusText = advanceRequest.status === 'approved' ? 'ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰' : 'ØªÙ… Ø±ÙØ¶';
      await storage.createNotification(
        advanceRequest.userId,
        "ØªØ­Ø¯ÙŠØ« Ø·Ù„Ø¨ Ø§Ù„Ø³Ù„ÙØ©",
        `${statusText} Ø·Ù„Ø¨ Ø§Ù„Ø³Ù„ÙØ© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ`,
        advanceRequest.status === 'approved' ? 'success' : 'error'
      );
      
      res.json(advanceRequest);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø·Ù„Ø¨ Ø§Ù„Ø³Ù„ÙØ©" });
    }
  });

  // Notifications routes
  app.get("/api/notifications", requireAuth, async (req, res) => {
    try {
      const notifications = await storage.getUserNotifications(req.user!.id);
      res.json(notifications);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª" });
    }
  });

  app.put("/api/notifications/:id/read", requireAuth, async (req, res) => {
    try {
      await storage.markNotificationAsRead(req.params.id);
      res.json({ message: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±" });
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±" });
    }
  });

  // Analytics routes
  app.get("/api/analytics/productivity", requireAuth, async (req, res) => {
    try {
      const startDate = new Date(req.query.startDate as string || Date.now() - 7 * 24 * 60 * 60 * 1000);
      const endDate = new Date(req.query.endDate as string || Date.now());
      const stats = await storage.getUserProductivityStats(req.user!.id, startDate, endDate);
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¥Ù†ØªØ§Ø¬ÙŠØ©" });
    }
  });

  app.get("/api/analytics/departments", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const stats = await storage.getDepartmentStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ù‚Ø³Ø§Ù…" });
    }
  });

  // HR Routes
  app.get("/api/hr/stats", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const users = await storage.getUsers();
      const activeEmployees = await storage.getAllActiveAuxSessions();
      const pendingLeaves = await storage.getPendingLeaveRequests();
      const allLeaves = await storage.getAllLeaveRequests();
      
      const totalEmployees = users.filter(u => u.isActive).length;
      const presentToday = activeEmployees.filter(e => e.status === 'working_on_project' || e.status === 'ready').length;
      const onLeave = allLeaves.filter(l => 
        l.status === 'approved' && 
        new Date(l.startDate) <= new Date() && 
        new Date(l.endDate) >= new Date()
      ).length;
      const pendingRequests = pendingLeaves.length;
      
      res.json({
        totalEmployees,
        presentToday,
        onLeave,
        pendingRequests,
      });
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ø§Ù„Ø¨Ø´Ø±ÙŠØ©" });
    }
  });

  app.get("/api/hr/payroll", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const users = await storage.getUsers();
      const activeUsers = users.filter(u => u.isActive);
      
      const payrollData = activeUsers.map(user => ({
        id: user.id,
        employee: user.fullName,
        department: user.department || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
        baseSalary: user.salary || 0,
        overtime: 0,
        deductions: 0,
        netSalary: user.salary || 0,
      }));
      
      res.json(payrollData);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±ÙˆØ§ØªØ¨" });
    }
  });

  app.get("/api/hr/reports", requireAuth, requireRole(['admin', 'sub-admin']), async (req, res) => {
    try {
      const users = await storage.getUsers();
      const activeUsers = users.filter(u => u.isActive);
      const allSessions = await storage.getAllAuxSessions();
      const allLeaves = await storage.getAllLeaveRequests();
      
      // Calculate attendance stats
      const last30Days = new Date();
      last30Days.setDate(last30Days.getDate() - 30);
      const recentSessions = allSessions.filter(s => new Date(s.startTime) >= last30Days && s.endTime);
      
      const totalWorkMinutes = recentSessions.reduce((sum, session) => {
        if (session.duration) {
          return sum + session.duration;
        }
        return sum;
      }, 0);
      
      const avgWorkHoursPerDay = totalWorkMinutes / (30 * 60);
      const attendanceRate = recentSessions.length > 0 ? 
        ((recentSessions.filter(s => s.status === 'working_on_project').length / recentSessions.length) * 100) : 0;
      
      const usedLeaveDays = allLeaves.filter(l => l.status === 'approved').reduce((sum, leave) => sum + leave.days, 0);
      
      // Department distribution
      const deptCounts: Record<string, number> = {};
      activeUsers.forEach(user => {
        const dept = user.department || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
        deptCounts[dept] = (deptCounts[dept] || 0) + 1;
      });
      
      const departmentDistribution = Object.entries(deptCounts).map(([dept, count]) => ({
        dept,
        count,
        percentage: (count / activeUsers.length) * 100,
      }));
      
      res.json({
        attendanceRate: Math.round(attendanceRate),
        avgWorkHoursPerDay: avgWorkHoursPerDay.toFixed(1),
        usedLeaveDays,
        departmentDistribution,
      });
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ø§Ù„Ø¨Ø´Ø±ÙŠØ©" });
    }
  });

  const httpServer = createServer(app);

  // WebSocket server for real-time updates
  const wss = new WebSocketServer({ server: httpServer, path: '/ws' });


  wss.on('error', (error) => {
    console.error('WebSocket server error:', error);
  });
  wss.on('connection', (ws) => {
    console.log('WebSocket client connected');

    ws.on('message', (message) => {
      try {
        const data = JSON.parse(message.toString());
        
        // Handle different message types
        switch (data.type) {
          case 'subscribe':
            // Handle subscription to updates
            break;
          case 'aux_update':
            // Broadcast AUX status updates
            wss.clients.forEach((client) => {
              if (client.readyState === ws.OPEN) {
                client.send(JSON.stringify({
                  type: 'aux_status_update',
                  data: data.payload
                }));
              }
            });
            break;
          case 'call_offer':
          case 'call_answer':
          case 'ice_candidate':
          case 'call_end':
            // Broadcast call signaling messages to all clients
            wss.clients.forEach((client) => {
              if (client !== ws && client.readyState === ws.OPEN) {
                client.send(JSON.stringify(data));
              }
            });
            break;
        }
      } catch (error) {
        console.error('WebSocket message error:', error);
      }
    });

    ws.on('close', () => {
      console.log('WebSocket client disconnected');
    });

  });

  // Chat Rooms Routes
  app.post("/api/chat/rooms", requireAuth, async (req, res) => {
    try {
      let imageUrl = undefined;
      
      // Handle base64 image upload
      if (req.body.image && req.body.image.startsWith('data:image/')) {
        try {
          const base64Data = req.body.image.split(',')[1];
          const imageBuffer = Buffer.from(base64Data, 'base64');
          const extension = req.body.image.split(';')[0].split('/')[1];
          const filename = Date.now() + '-' + Math.round(Math.random() * 1E9) + '.' + extension;
          const fs = await import('fs/promises');
          await fs.writeFile(`uploads/${filename}`, imageBuffer);
          imageUrl = `/uploads/${filename}`;
        } catch (imgError) {
          console.error("Error saving room image:", imgError);
        }
      }
      
      const room = await storage.createChatRoom({
        name: req.body.name,
        type: req.body.type || 'group',
        createdBy: req.user!.id,
        image: imageUrl,
      });
      
      if (req.body.memberIds && Array.isArray(req.body.memberIds)) {
        for (const memberId of req.body.memberIds) {
          await storage.addChatRoomMember(room.id, memberId);
        }
      }
      
      await storage.addChatRoomMember(room.id, req.user!.id);
      
      res.status(201).json(room);
    } catch (error) {
      console.error("Error creating chat room:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ ØºØ±ÙØ© Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©" });
    }
  });

  app.post("/api/chat/private", requireAuth, async (req, res) => {
    try {
      const { otherUserId } = req.body;
      const room = await storage.getOrCreatePrivateChat(req.user!.id, otherUserId);
      res.json(room);
    } catch (error) {
      console.error("Error creating private chat:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ©" });
    }
  });

  app.get("/api/chat/rooms", requireAuth, async (req, res) => {
    try {
      await storage.ensureUserInCommonRoom(req.user!.id);
      const rooms = await storage.getUserChatRooms(req.user!.id);
      res.json(rooms);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ ØºØ±Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©" });
    }
  });

  app.get("/api/chat/rooms/:id", requireAuth, async (req, res) => {
    try {
      const room = await storage.getChatRoom(req.params.id);
      if (!room) {
        return res.status(404).json({ message: "ØºØ±ÙØ© Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      res.json(room);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ ØºØ±ÙØ© Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©" });
    }
  });
  app.put("/api/chat/rooms/:id/image", requireAuth, async (req, res) => {
    try {
      const room = await storage.updateChatRoomImage(req.params.id, req.body.image);
      res.json(room);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« ØµÙˆØ±Ø© Ø§Ù„ØºØ±ÙØ©" });
    }
  });


  // Chat Messages Routes
  app.post("/api/chat/messages", requireAuth, async (req, res) => {
    try {
      const message = await storage.createChatMessage({
        roomId: req.body.roomId,
        senderId: req.user!.id,
        content: req.body.content,
        messageType: req.body.messageType || 'text',
        attachments: req.body.attachments,
        replyTo: req.body.replyTo,
      });
      
      // Create notifications for room members
      const room = await storage.getChatRoom(req.body.roomId);
      const roomMembers = await storage.getChatRoomMembers(req.body.roomId);
      
      for (const member of roomMembers) {
        if (member.id !== req.user!.id) {
          const notification = await storage.createNotification(
            member.id,
            room?.name || 'Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©',
            `${req.user!.fullName}: ${req.body.content || 'Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©'}`,
            'info',
            { roomId: req.body.roomId, messageId: message.id }
          );
          
          // Broadcast notification
          wss.clients.forEach((client) => {
            if (client.readyState === client.OPEN) {
              client.send(JSON.stringify({
                type: 'new_notification',
                data: notification
              }));
            }
          });
        }
      }
      
      wss.clients.forEach((client) => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify({
            type: 'new_message',
            data: message
          }));
        }
      });
      
      res.status(201).json(message);
    } catch (error) {
      console.error("Error creating message:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©" });
    }
  });

  app.get("/api/chat/messages/:roomId", requireAuth, async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 50;
      const messages = await storage.getChatMessages(req.params.roomId, limit);
      res.json(messages);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„" });
    }
  });

  app.put("/api/chat/messages/:id", requireAuth, async (req, res) => {
    try {
      const message = await storage.updateChatMessage(req.params.id, req.body.content);
      if (!message) {
        return res.status(404).json({ message: "Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      
      wss.clients.forEach((client) => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify({
            type: 'message_updated',
            data: message
          }));
        }
      });
      
      res.json(message);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ø§Ù„Ø©" });
    }
  });

  app.delete("/api/chat/messages/:id", requireAuth, async (req, res) => {
    try {
      const success = await storage.deleteChatMessage(req.params.id);
      if (!success) {
        return res.status(404).json({ message: "Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
      
      wss.clients.forEach((client) => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify({
            type: 'message_deleted',
            data: { messageId: req.params.id }
          }));
        }
      });
      
      res.json({ message: "ØªÙ… Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­" });
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©" });
    }
  });

  // Message Reactions Routes
  app.post("/api/chat/reactions", requireAuth, async (req, res) => {
    try {
      const reaction = await storage.addMessageReaction(
        req.body.messageId,
        req.user!.id,
        req.body.emoji
      );
      
      wss.clients.forEach((client) => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify({
            type: 'reaction_added',
            data: reaction
          }));
        }
      });
      
      res.status(201).json(reaction);
    } catch (error) {
      console.error("Error adding reaction:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªÙØ§Ø¹Ù„" });
    }
  });

  app.delete("/api/chat/reactions", requireAuth, async (req, res) => {
    try {
      await storage.removeMessageReaction(
        req.body.messageId,
        req.user!.id,
        req.body.emoji
      );
      
      wss.clients.forEach((client) => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify({
            type: 'reaction_removed',
            data: {
              messageId: req.body.messageId,
              userId: req.user!.id,
              emoji: req.body.emoji
            }
          }));
        }
      });
      
      res.json({ message: "ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙØ§Ø¹Ù„ Ø¨Ù†Ø¬Ø§Ø­" });
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙØ§Ø¹Ù„" });
    }
  });

  // Google Calendar Routes (VPS-Compatible OAuth2)
  app.get("/api/google-calendar/auth-url", requireAuth, async (req, res) => {
    try {
      const { getGoogleAuthUrl } = await import("./google-calendar-integration");
      const authUrl = getGoogleAuthUrl();
      if (!authUrl) {
        return res.status(400).json({ 
          message: "ÙŠØ±Ø¬Ù‰ ØªÙƒÙˆÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø¹ØªÙ…Ø§Ø¯ Google OAuth2 Ø£ÙˆÙ„Ø§Ù‹. Ø±Ø§Ø¬Ø¹ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª ÙÙŠ server/google-calendar-integration.ts" 
        });
      }
      res.json({ authUrl });
    } catch (error) {
      res.status(500).json({ message: "ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø§Ø¨Ø· Ø§Ù„ØªÙÙˆÙŠØ¶" });
    }
  });

  app.get("/api/google-calendar/callback", async (req, res) => {
    try {
      const { code } = req.query;
      if (!code || typeof code !== 'string') {
        return res.status(400).send('Missing authorization code');
      }
      
      const { handleGoogleCallback } = await import("./google-calendar-integration");
      await handleGoogleCallback(code);
      
      // Redirect to dashboard or settings page
      res.redirect('/dashboard?google-calendar=connected');
    } catch (error) {
      console.error('OAuth callback error:', error);
      res.redirect('/dashboard?google-calendar=error');
    }
  });

  app.get("/api/google-calendar/status", requireAuth, async (req, res) => {
    try {
      const connected = await isGoogleCalendarConnected();
      res.json({ connected });
    } catch (error) {
      res.json({ connected: false });
    }
  });

  app.post("/api/google-calendar/schedule-meeting", requireAuth, async (req, res) => {
    try {
      const { title, participantIds, startTime, endTime, meetingLink } = req.body;
      
      // Validation
      if (!title || !participantIds || !Array.isArray(participantIds) || participantIds.length === 0) {
        return res.status(400).json({ message: "Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØ§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ù…Ø·Ù„ÙˆØ¨Ø§Ù†" });
      }
      
      const start = new Date(startTime);
      const end = new Date(endTime);
      
      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        return res.status(400).json({ message: "ØªÙˆØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­Ø©" });
      }
      
      if (start >= end) {
        return res.status(400).json({ message: "ÙˆÙ‚Øª Ø§Ù„Ø¨Ø¯Ø¡ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ÙˆÙ‚Øª Ø§Ù„Ù†Ù‡Ø§ÙŠØ©" });
      }
      
      // Allow users to provide their own meeting link instead of relying on Google Calendar
      const finalMeetingLink = meetingLink || `https://meet.example.com/${Date.now()}-${Math.random().toString(36).substring(7)}`;
      
      const meeting = await storage.createMeeting({
        title,
        description: `Ø§Ø¬ØªÙ…Ø§Ø¹ Ù…Ø¹ ${participantIds.length} Ù…Ø´Ø§Ø±Ùƒ`,
        meetingLink: finalMeetingLink,
        scheduledBy: req.user!.id,
        startTime: new Date(startTime),
        endTime: new Date(endTime),
      });
      
      const allParticipantIds = [...participantIds, req.user!.id];
      
      for (const participantId of participantIds) {
        await storage.addMeetingParticipant(meeting.id, participantId);
      }
      await storage.addMeetingParticipant(meeting.id, req.user!.id);
      
      let chatRoom;
      if (participantIds.length === 1) {
        chatRoom = await storage.getOrCreatePrivateChat(req.user!.id, participantIds[0]);
      } else {
        chatRoom = await storage.createChatRoom({
          name: title,
          type: "group",
          createdBy: req.user!.id,
        });
        
        for (const participantId of allParticipantIds) {
          await storage.addChatRoomMember(chatRoom.id, participantId);
        }
      }
      
      const message = await storage.createChatMessage({
        roomId: chatRoom.id,
        senderId: req.user!.id,
        content: `ðŸŽ¥ ${title}\n\nØ§Ù†Ø¶Ù… Ù„Ù„Ø§Ø¬ØªÙ…Ø§Ø¹: ${finalMeetingLink}`,
        messageType: "meeting_link",
        attachments: [{
          name: title,
          url: finalMeetingLink,
          type: "meeting"
        }],
      });
      
      // Create notifications for room members
      const room = await storage.getChatRoom(req.body.roomId);
      const roomMembers = await storage.getChatRoomMembers(req.body.roomId);
      
      for (const member of roomMembers) {
        if (member.id !== req.user!.id) {
          const notification = await storage.createNotification(
            member.id,
            room?.name || 'Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©',
            `${req.user!.fullName}: ${req.body.content || 'Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©'}`,
            'info',
            { roomId: req.body.roomId, messageId: message.id }
          );
          
          // Broadcast notification
          wss.clients.forEach((client) => {
            if (client.readyState === client.OPEN) {
              client.send(JSON.stringify({
                type: 'new_notification',
                data: notification
              }));
            }
          });
        }
      }
      
      for (const participantId of participantIds) {
        const notification = await storage.createNotification(
          participantId,
          "Ø§Ø¬ØªÙ…Ø§Ø¹ Ø¬Ø¯ÙŠØ¯",
          `${req.user!.fullName} Ù‚Ø§Ù… Ø¨Ø¬Ø¯ÙˆÙ„Ø© Ø§Ø¬ØªÙ…Ø§Ø¹: ${title}`,
          "info"
        );
        
        wss.clients.forEach((client) => {
          if (client.readyState === client.OPEN) {
            client.send(JSON.stringify({
              type: "new_notification",
              data: notification
            }));
          }
        });
      }
      
      wss.clients.forEach((client) => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify({
            type: "new_message",
            data: message
          }));
          client.send(JSON.stringify({
            type: "new_meeting",
            data: meeting
          }));
        }
      });
      
      res.status(201).json({ ...meeting, chatRoomId: chatRoom.id });
    } catch (error) {
      console.error("Error scheduling meeting:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹" });
    }
  });

  // Meeting scheduling route (legacy endpoint for sidebar)
  app.post("/api/meetings/schedule", requireAuth, async (req, res) => {
    try {
      const { title, participantIds } = req.body;
      
      if (!title || !participantIds || !Array.isArray(participantIds) || participantIds.length === 0) {
        return res.status(400).json({ message: "Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØ§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ù…Ø·Ù„ÙˆØ¨Ø§Ù†" });
      }
      
      const meetingLink = `https://meet.example.com/${Date.now()}-${Math.random().toString(36).substring(7)}`;
      
      const meeting = await storage.createMeeting({
        title,
        description: `Ø§Ø¬ØªÙ…Ø§Ø¹ Ù…Ø¹ ${participantIds.length} Ù…Ø´Ø§Ø±Ùƒ`,
        meetingLink,
        scheduledBy: req.user!.id,
        startTime: new Date(),
        endTime: null,
      });
      
      for (const participantId of participantIds) {
        await storage.addMeetingParticipant(meeting.id, participantId);
        const privateRoom = await storage.getOrCreatePrivateChat(req.user!.id, participantId);
        await storage.createChatMessage({
          roomId: privateRoom.id,
          senderId: req.user!.id,
          content: `ðŸŽ¥ ${title}\n\nØ§Ù†Ø¶Ù… Ù„Ù„Ø§Ø¬ØªÙ…Ø§Ø¹: ${meetingLink}`,
          messageType: "meeting_link",
          attachments: [{ name: title, url: meetingLink, type: "meeting" }],
        });
        await storage.createNotification(participantId, "Ø§Ø¬ØªÙ…Ø§Ø¹ Ø¬Ø¯ÙŠØ¯", `${req.user!.fullName} Ù‚Ø§Ù… Ø¨Ø¬Ø¯ÙˆÙ„Ø© Ø§Ø¬ØªÙ…Ø§Ø¹: ${title}`, "info");
      }
      
      res.status(201).json({ ...meeting, meetingLink });
    } catch (error) {
      console.error("Error scheduling meeting:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹" });
    }
  });
  app.post("/api/meetings", requireAuth, async (req, res) => {
    try {
      const meeting = await storage.createMeeting({
        title: req.body.title,
        description: req.body.description,
        meetingLink: req.body.meetingLink,
        scheduledBy: req.user!.id,
        startTime: new Date(req.body.startTime),
        endTime: req.body.endTime ? new Date(req.body.endTime) : null,
      });
      
      if (req.body.participantIds && Array.isArray(req.body.participantIds)) {
        for (const participantId of req.body.participantIds) {
          await storage.addMeetingParticipant(meeting.id, participantId);
          
          const privateRoom = await storage.getOrCreatePrivateChat(req.user!.id, participantId);
          
          await storage.createChatMessage({
            roomId: privateRoom.id,
            senderId: req.user!.id,
            content: `ØªÙ… Ø¬Ø¯ÙˆÙ„Ø© Ø§Ø¬ØªÙ…Ø§Ø¹: ${meeting.title}`,
            messageType: 'meeting_link',
            attachments: [{
              name: meeting.title,
              url: meeting.meetingLink,
              type: 'meeting'
            }],
          });
          
          await storage.createNotification(
            participantId,
            "Ø§Ø¬ØªÙ…Ø§Ø¹ Ø¬Ø¯ÙŠØ¯",
            `ØªÙ… Ø¬Ø¯ÙˆÙ„Ø© Ø§Ø¬ØªÙ…Ø§Ø¹: ${meeting.title}`,
            "info"
          );
        }
      }
      
      wss.clients.forEach((client) => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify({
            type: 'new_meeting',
            data: meeting
          }));
        }
      });
      
      res.status(201).json(meeting);
    } catch (error) {
      console.error("Error creating meeting:", error);
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹" });
    }
  });

  app.get("/api/meetings", requireAuth, async (req, res) => {
    try {
      const meetings = await storage.getUserMeetings(req.user!.id);
      res.json(meetings);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹Ø§Øª" });
    }
  });

  app.get("/api/meetings/:id", requireAuth, async (req, res) => {
    try {
      const meeting = await storage.getMeeting(req.params.id);
      if (!meeting) {
        return res.status(404).json({ message: "Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      res.json(meeting);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹" });
    }
  });

  // Rewards endpoint
  app.get("/api/user/rewards", requireAuth, async (req, res) => {
    try {
      const rewards = await storage.getUserRewards(req.user!.id);
      res.json(rewards);
    } catch (error) {
      res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª" });
    }
  });

  // Broadcast real-time updates periodically
  setInterval(async () => {
    try {
      const activeEmployees = await storage.getAllActiveAuxSessions();
      wss.clients.forEach((client) => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify({
            type: 'employee_status_update',
            data: activeEmployees
          }));
        }
      });
    } catch (error) {
      console.error('Broadcast error:', error);
    }
  }, 5000); // Broadcast every 5 seconds

  return httpServer;
}